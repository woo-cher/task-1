# ✏️ TOY TASK - 매우 간단한 장바구니 예제
### - Controller, Service, Repository 구조로 시작하여, Clean Architecture 형태로 변형해가는 과정을 담았습니다.
### - 간단한 예제를 코딩해보면서, `저의 작업 방식` 을 보여줄 수 있을 것 같아서 작업하게 되었습니다.

## 🧱 과제 조건

> ### - 장바구니 생성 할 수 있다
> ### - 장바구니에 아이템을 담을 수 있다
> ### - 상품 별 배송비가 존재한다
> ### - 장바구니에 담긴 상품들의 가격을 총합할 수 있다
> ### - 주문 목록을 조회 할 수 있다
> ### - 프레임워크, 데이터베이스는 사용하지 않는다

## 🛠️ 기술 스텍

| 기술                           | 설명                                                    |
|------------------------------|-------------------------------------------------------|
| **Kotlin**                   | 전 직장에서 접한 언어로 사용하기 위함                                 |
| **Gradle**                   | 멀티 모듈 구성 및 의존성 관리                                     |
| **Kotest**                   | 코틀린 기반 및 테스트 스펙을 활용하기 위함                              |
| **Clean Architecture** | controller 계층은 제외하고, domain, usecase, repository 로 분리 |
| **No Framework**             | Spring 등 프레임워크에 의존하지 않음                               |

## 🧪 테스트 전략
### - 비즈니스 로직의 경우, Domain 모듈에서 Unit Test 로 처리
### - 핵심 모듈인 UseCase 에서 Integration Test 로 실제 Input, Output 테스트
### - Kotest 의 `desc spec` 을 활용하여, 테스트 하고자 하는 목적이 분명하도록 처리
### - 테스트에 필요한 DI 는, TestFactory 가 맡아 처리


## ❓ 고민했던 요소들

| 고민                     | 해결 방법                                                                                                                                                                 |
|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **테스트 코드**는 어떻게 작성할까?  | 모든 테스트에 대해, **성공 케이스** 와 **실패 케이스** 를 작성하자<br/> **외부 시스템과의 연동**이 존재하지 않으므로, **Mock** 형태 테스트는 사용하지 말자<br/> 도메인 로직 테스트는 Unit 테스트를 생성하자<br/> 모든 로직들에 대한 **통합 테스트**를 작성하자 |
| **서비스 코드의 책임이 늘어나고 있다** | MVC 형태 Service 클래스에 구현된 함수가 늘어나 가독성 및 유지 보수성이 떨어짐 -> 클린 아키텍처 구조로 변경                                                                                                   |                                                                                                                                                                      |
| **엔터티 Class 의존성 남발되고 있다** | **Repisotry 계층에서 사용되는 Entity 클래스가 다른 계층에서 남발**되어 좋지 않아 보임 </br> - **엔터티 클래스**는 Repository 모듈만 알고 있어야 한다 **(데이터 일관성 유지)**  </br> - 이에 따라, 응답 형태를 줄때에는 **EntityData 클래스**를 활용하도록 처리함
| **모듈 별 요청과 응답 처리는?**   | 하나의 DTO 로 모두 처리하기 보단, **계층별로 DTO** 를 두어 각 계층에서 하나의 역할을 수행하도록 처리
| **프레임워크가 없는데 예외 처리는 어떻게 할까** | **usecase** 에서`try-catch` 를 매번 작성하기는 번거롭다 </br> - **Exception Handler** 및 **UseCaseProxy**를 구현 </br> - 따라서, **UseCase** 실행 시, **handle { .. }** 블럭으로 감싸 실행하도록 처리 </br> - **CustomException** 구현하여 에러 코드 및 예외 메시지 처리 </br> - **해당 예외를 잡아 코드, 메시지 출력** 하는 정도만 구현
| **usecase 유효성 검증**     | **검증 책임**까지 **usecase** 가 맡을 필요가 있을까?? </br> -  **usecase는** 필요한 의존성들을 모아 오케스트레이션 역할 </br> - **유효성 검증**은 **비즈니스 로직**이므로 doamin 모듈에 policy 클래스 형태로 구현 </br> - 필요한 객체를 **usecase** 로 부터 전달 받아 검증 후 결과 처리

## 📌 향후 개선점

### - UseCaseProxy 를 통하지 않고, UseCase 를 실행할 수 있다
> - **<문제>** 현재 테스트 모듈에서 **UseCaseProxy** 가 아닌 **UseCase 구현체를 직접 생성**하여 호출해버릴 수 있어 예외 핸들링이 보장되지 않는다
> - **<개선안>** 중간 계층 모듈을 두어, 테스트 모듈에서 **usecase 의존성** 제거
> - **<개선안2>** **UseCaseTemplate** 을 두고, **handle** {...} 처리되도록 **템플릿화** 한다 

### - 프레임워크를 사용하지 않으므로, UseCase<I, O> 와 같은 제네릭을 쓸 필요가 없다
> - **<문제>** 객체 의존성을 직접 주입하기 때문에, 제네릭 타입이 모호하며 가독성이 떨어진다
> - **<개선안>** 제네릭 타입을 제거하고, 직접 객체 타입을 지정
